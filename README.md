
## Completed CSC2035 Assignment - systems programming and inter-process communication (IPC) 

Introduction

For this assignment I was provided with a partially completed project to demonstrate different approaches to maintaining the integrity of an inter-process communication (IPC) application (busy waiting and semaphore approaches). 
My task was to complete the project by implementing supporting library functions. It helped me to reinforce, in practice, the operating systems theory I learnt as part of the CSC2035 module.



### The application/simulation

As shown in the following figure, the project simulates an application in which a set of one or more producer processes creates jobs to submit (enqueue) to a FIFO (first-in, first-out) job queue for one or more consumer processes to dequeue and process. The job queue is in shared memory. In addition each process (producer or consumer) has a private persistent log of jobs that they have produced (if they are a producer) or consumed (if they are a consumer). Many common client/server applications follow this model of one or more producers (clients) submitting work to be done by a one or more consumers (servers).

![Diagram illustrating the application/simulation ](https://github.com/Preffet/markdown-previewer/blob/master/applicationDiagram.jpg)


### The overall application proceeds as follows :
- While a producer process has jobs to be done, they produce a job, enqueue the job on the job queue and log the job in their private log. Enqueuing a job blocks if the queue is full. If there are multiple producers, they are not able to overwrite each other's jobs despite sharing the same queue.
- While there are jobs to consume, a consumer process dequeues the next job from the queue, logs the job in their private log and processes the job. Dequeueing a job blocks if the queue is empty. If there are multiple consumers, each job is only consumed by one consumer despite sharing the queue with the other consumers.

### A job is represented by the following attributes:
- the process id (pid) of the producer of the job
- a job id generated by the producer of the job that is locally unique to that producer
- a job label - an application-specific string that, for example, may describe the job

The combination of job pid and id means that, assuming integrity constraints are maintained, each job will be globally unique even when multiple producers are producing jobs. The job id that is locally unique for a given producer is made globally unique for all producers by qualifying the job id with the producer's globally unique pid. In a real-world version of the application, the combination of pid and job id could be replaced by a could be replaced by an absolute URL that is qualified by the producer's domain name. The label could be replaced by a URL link to a job specification. The overall integrity constraint is that producers should not produce duplicate jobs and each job should only be consumed once by one consumer. That is, no two consumers should consume the same job.
